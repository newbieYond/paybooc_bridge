<!DOCTYPE html>
<html lang="ko" class="dark">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>재무실적관리 대시보드</title>

    <!-- Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link
        href="https://fonts.googleapis.com/css2?family=Outfit:wght@300;400;500;600;700&family=Noto+Sans+KR:wght@300;400;500;700&display=swap"
        rel="stylesheet">

    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            darkMode: 'class',
            theme: {
                extend: {
                    fontFamily: {
                        sans: ['Outfit', 'Noto Sans KR', 'sans-serif'],
                    },
                    colors: {
                        brand: {
                            50: '#f0fdfa',
                            100: '#ccfbf1',
                            500: '#14b8a6',
                            600: '#0d9488',
                            900: '#134e4a',
                        },
                        dark: {
                            bg: '#0f172a',
                            card: '#1e293b',
                            border: '#334155'
                        }
                    }
                }
            }
        }
    </script>

    <!-- Libraries -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://unpkg.com/@phosphor-icons/web"></script>

    <style>
        body {
            background-color: #0f172a;
            color: #e2e8f0;
        }

        .glass-panel {
            background: rgba(30, 41, 59, 0.7);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.08);
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
        }

        .table-header {
            background: rgba(15, 23, 42, 0.9);
            position: sticky;
            top: 0;
            z-index: 10;
        }

        /* Custom Scrollbar */
        .custom-scrollbar::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        .custom-scrollbar::-webkit-scrollbar-track {
            background: #0f172a;
        }

        .custom-scrollbar::-webkit-scrollbar-thumb {
            background: #334155;
            border-radius: 4px;
        }

        .custom-scrollbar::-webkit-scrollbar-thumb:hover {
            background: #475569;
        }

        .caret-icon {
            transition: transform 0.2s ease;
        }

        .caret-open {
            transform: rotate(90deg);
        }

        /* Sidebar & Layout */
        .layout-container {
            display: flex;
            gap: 1.5rem;
            align-items: flex-start;
            /* Prevent sidebar from stretching */
        }

        .sidebar {
            width: 280px;
            flex-shrink: 0;
            background: rgba(30, 41, 59, 0.7);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-radius: 1rem;
            padding: 1.5rem;
            height: calc(100vh - 3rem);
            position: sticky;
            top: 1.5rem;
            overflow-y: auto;
            overflow-y: auto;
            display: none;
            /* Hidden by default */
            flex-direction: column;
        }

        .main-content {
            flex-grow: 1;
            min-width: 0;
            display: flex;
            flex-direction: column;
            gap: 2rem;
        }

        /* Tree View */
        .tree-container {
            flex-grow: 1;
            overflow-y: auto;
        }

        .tree-node {
            margin-bottom: 2px;
        }

        .tree-children {
            margin-left: 1.2rem;
            border-left: 1px solid rgba(255, 255, 255, 0.1);
            padding-left: 0.5rem;
            display: none;
            /* Default collapsed or handle via JS */
        }

        .tree-children.expanded {
            display: block;
        }

        .tree-row {
            display: flex;
            align-items: center;
            padding: 6px 0;
            gap: 8px;
            color: #cbd5e1;
            font-size: 0.9rem;
            border-radius: 4px;
            transition: background 0.1s;
        }

        .tree-row:hover {
            background: rgba(255, 255, 255, 0.05);
        }

        .tree-caret {
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            color: #64748b;
            transition: transform 0.2s, color 0.2s;
        }

        .tree-caret:hover {
            color: #94a3b8;
        }

        .tree-caret.expanded {
            transform: rotate(90deg);
        }

        .tree-caret.leaf {
            visibility: hidden;
            pointer-events: none;
        }

        .tree-checkbox {
            appearance: none;
            width: 16px;
            height: 16px;
            border: 2px solid #475569;
            border-radius: 4px;
            background: #1e293b;
            cursor: pointer;
            position: relative;
            flex-shrink: 0;
        }

        .tree-checkbox:checked {
            background: #14b8a6;
            border-color: #14b8a6;
        }

        .tree-checkbox:checked::after {
            content: '✔';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 10px;
            font-weight: bold;
        }

        .tree-checkbox:indeterminate {
            background: #0f766e;
            border-color: #0f766e;
        }

        .tree-checkbox:indeterminate::after {
            content: '-';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 14px;
            line-height: 10px;
        }

        .tree-label {
            cursor: pointer;
            flex-grow: 1;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
    </style>
</head>

<body class="min-h-screen p-6 font-sans">

    <div class="layout-container p-6">
        <!-- Sidebar -->
        <aside class="sidebar custom-scrollbar">
            <h2 class="text-lg font-bold text-white mb-4 flex items-center gap-2">
                <i class="ph-fill ph-funnel text-brand-500"></i>
                필터
            </h2>
            <!-- Item Filter -->
            <h3 class="text-sm font-bold text-slate-400 mb-2 uppercase tracking-wider border-b border-dark-border pb-2">
                항목 (Category)</h3>
            <div class="mb-4 flex gap-2">
                <button onclick="expandAll(true)"
                    class="text-xs px-2 py-1 bg-slate-700 hover:bg-slate-600 rounded text-slate-300">모두 펼치기</button>
                <button onclick="expandAll(false)"
                    class="text-xs px-2 py-1 bg-slate-700 hover:bg-slate-600 rounded text-slate-300">모두 접기</button>
            </div>
            <div id="filter-tree" class="tree-container custom-scrollbar mb-6" style="flex: 0 0 45%; max-height: 45%;">
                <!-- Tree will be injected here -->
            </div>

            <!-- Dept Filter -->
            <h3
                class="text-sm font-bold text-slate-400 mb-2 mt-4 uppercase tracking-wider border-b border-dark-border pb-2 pt-2 border-t border-slate-700/50">
                조직 (Dept)</h3>
            <div class="mb-4 flex gap-2">
                <button onclick="toggleAllDepts(true)"
                    class="text-xs px-2 py-1 bg-slate-700 hover:bg-slate-600 rounded text-slate-300">전체 선택</button>
                <button onclick="toggleAllDepts(false)"
                    class="text-xs px-2 py-1 bg-slate-700 hover:bg-slate-600 rounded text-slate-300">전체 해제</button>
            </div>
            <div id="dept-filter-list" class="tree-container custom-scrollbar" style="flex: 1;">
                <!-- Dept List will be injected here -->
            </div>
        </aside>

        <!-- Main Content -->
        <main class="main-content">
            <!-- Header -->
            <header class="flex justify-between items-center bg-transparent">
                <div>
                    <h1 class="text-3xl font-bold text-white tracking-tight flex items-center gap-3">
                        <i class="ph-fill ph-chart-polar text-brand-500"></i>
                        재무실적관리 대시보드
                    </h1>
                    <p class="text-slate-400 mt-1 text-sm">Financial Performance Management System</p>
                </div>
                <div class="flex items-center gap-4">
                    <button onclick="toggleSidebar()"
                        class="p-2 rounded-lg bg-dark-card hover:bg-slate-700 border border-dark-border text-slate-300 transition-colors"
                        title="필터 토글">
                        <i class="ph-fill ph-funnel text-xl"></i>
                    </button>
                    <div class="text-right">
                        <div id="current-date" class="text-white font-medium"></div>
                        <div id="current-time" class="text-brand-500 text-sm font-bg"></div>
                        <div id="data-source" class="text-xs text-slate-500 mt-1">Initializing...</div>
                    </div>
                    <button onclick="window.location.reload()"
                        class="p-2 rounded-lg bg-dark-card hover:bg-slate-700 border border-dark-border text-slate-300 transition-colors">
                        <i class="ph ph-arrow-clockwise text-xl"></i>
                    </button>
                </div>
            </header>

            <!-- Summary Section (CSV 1) -->
            <section id="summary-section" class="grid grid-cols-1 lg:grid-cols-2 gap-6">
                <!-- Revenue Card -->
                <article class="glass-panel rounded-2xl p-6 relative overflow-hidden group">
                    <div class="absolute top-0 right-0 p-4 opacity-10 group-hover:opacity-20 transition-opacity">
                        <i class="ph-fill ph-trend-up text-9xl text-brand-500"></i>
                    </div>

                    <div class="relative z-10">
                        <div class="flex justify-between items-start mb-4">
                            <div>
                                <span
                                    class="inline-block px-3 py-1 rounded-full text-xs font-semibold bg-brand-500/20 text-brand-500 border border-brand-500/30 mb-2">
                                    Revenue
                                </span>
                                <h2 class="text-2xl font-bold text-white">수익</h2>
                            </div>
                        </div>

                        <div class="grid grid-cols-3 gap-4 mb-6">
                            <div>
                                <p class="text-slate-400 text-xs uppercase tracking-wider">전년도 실적</p>
                                <p class="text-xl font-bold text-slate-200" id="rev-prev">Loading...</p>
                            </div>
                            <div>
                                <p class="text-slate-400 text-xs uppercase tracking-wider">당년 경영계획</p>
                                <p class="text-xl font-bold text-slate-200" id="rev-plan">Loading...</p>
                            </div>
                            <div>
                                <p class="text-slate-400 text-xs uppercase tracking-wider">당년 목표</p>
                                <p class="text-2xl font-bold text-white" id="rev-goal">Loading...</p>
                            </div>
                        </div>

                        <div class="h-48 w-full">
                            <canvas id="revenueChart"></canvas>
                        </div>
                    </div>
                </article>

                <!-- Profit Card -->
                <article class="glass-panel rounded-2xl p-6 relative overflow-hidden group">
                    <div class="absolute top-0 right-0 p-4 opacity-10 group-hover:opacity-20 transition-opacity">
                        <i class="ph-fill ph-coins text-9xl text-blue-500"></i>
                    </div>

                    <div class="relative z-10">
                        <div class="flex justify-between items-start mb-4">
                            <div>
                                <span
                                    class="inline-block px-3 py-1 rounded-full text-xs font-semibold bg-blue-500/20 text-blue-400 border border-blue-500/30 mb-2">
                                    Operating Profit
                                </span>
                                <h2 class="text-2xl font-bold text-white">영업이익</h2>
                            </div>
                        </div>

                        <div class="grid grid-cols-3 gap-4 mb-6">
                            <div>
                                <p class="text-slate-400 text-xs uppercase tracking-wider">전년도 실적</p>
                                <p class="text-xl font-bold text-slate-200" id="prof-prev">Loading...</p>
                            </div>
                            <div>
                                <p class="text-slate-400 text-xs uppercase tracking-wider">당년 경영계획</p>
                                <p class="text-xl font-bold text-slate-200" id="prof-plan">Loading...</p>
                            </div>
                            <div>
                                <p class="text-slate-400 text-xs uppercase tracking-wider">당년 목표</p>
                                <p class="text-2xl font-bold text-white" id="prof-goal">Loading...</p>
                            </div>
                        </div>

                        <div class="h-48 w-full">
                            <canvas id="profitChart"></canvas>
                        </div>
                    </div>
                </article>
            </section>

            <!-- Detailed Table Section (CSV 2) -->
            <section class="glass-panel rounded-2xl p-1 overflow-hidden">
                <div class="p-6 border-b border-dark-border flex justify-between items-center">
                    <h3 class="text-xl font-bold text-white flex items-center gap-2">
                        <i class="ph-fill ph-table text-slate-400"></i>
                        상세 실적 현황
                    </h3>
                    <div class="flex gap-2">
                        <div class="relative">
                            <i
                                class="ph ph-magnifying-glass absolute left-3 top-1/2 transform -translate-y-1/2 text-slate-500"></i>
                            <input type="text" id="searchInput" placeholder="검색..."
                                class="bg-dark-bg border border-dark-border text-sm rounded-lg pl-10 pr-4 py-2 focus:ring-2 focus:ring-brand-500 focus:border-brand-500 text-white placeholder-slate-500 w-64">
                        </div>
                    </div>
                </div>

                <div class="overflow-x-auto max-h-[600px] overflow-y-auto custom-scrollbar">
                    <table class="w-full text-sm text-left text-slate-300 min-w-[1200px]">
                        <thead
                            class="text-xs text-slate-400 uppercase bg-dark-bg table-header shadow-md sticky top-0 z-10">
                            <tr>
                                <th scope="col" class="px-4 py-3 whitespace-nowrap w-[100px]">대분류</th>
                                <th scope="col" class="px-4 py-3 whitespace-nowrap w-[120px]">중분류</th>
                                <th scope="col" class="px-4 py-3 whitespace-nowrap w-[120px]">소분류</th>
                                <th scope="col" class="px-4 py-3 whitespace-nowrap w-[150px]">세분류</th>
                                <th scope="col" class="px-4 py-3 whitespace-nowrap w-[120px]">담당조직</th>
                                <th scope="col" class="px-4 py-3 text-right whitespace-nowrap w-[100px]">전월달성률</th>
                                <th scope="col" class="px-4 py-3 text-right whitespace-nowrap w-[100px]">당월목표</th>
                                <th scope="col" class="px-4 py-3 text-right whitespace-nowrap w-[100px]">당월추정</th>
                                <th scope="col" class="px-4 py-3 text-right whitespace-nowrap w-[100px]">당월달성률</th>
                                <th scope="col" class="px-4 py-3 text-right whitespace-nowrap w-[100px]">연간목표</th>
                            </tr>
                        </thead>
                        <tbody id="details-table-body" class="divide-y divide-dark-border">
                            <!-- Data Rows will be inserted here -->
                        </tbody>
                    </table>
                </div>
            </section>
        </main>
    </div>

    <script>
        // Initialize
        let allDetailsData = [];
        let filterTreeData = [];
        let deptFilterData = []; // Store dept filter state

        loadData();

        // --- 1. Utilities ---
        const formatNumber = (num) => new Intl.NumberFormat('ko-KR').format(num);
        const parseNum = (str) => parseFloat(String(str).replace(/,/g, '')) || 0;

        function toggleSidebar() {
            const sidebar = document.querySelector('.sidebar');
            const isHidden = window.getComputedStyle(sidebar).display === 'none';
            sidebar.style.display = isHidden ? 'flex' : 'none';
        }

        function updateTime() {
            const now = new Date();
            document.getElementById('current-date').textContent = now.toLocaleDateString('ko-KR', { year: 'numeric', month: 'long', day: 'numeric', weekday: 'long' });
            document.getElementById('current-time').textContent = now.toLocaleTimeString('ko-KR');
        }
        setInterval(updateTime, 1000);
        updateTime();

        // --- 2. Data Fetching ---

        async function loadData() {
            try {
                // Try fetching real CSV files
                const [summaryRes, detailsRes] = await Promise.all([
                    fetch('financial_summary.csv'),
                    fetch('financial_details.csv')
                ]);

                if (!summaryRes.ok || !detailsRes.ok) throw new Error("CSV Fetch failed");

                const summaryText = await summaryRes.text();
                const detailsText = await detailsRes.text();

                const detailsData = Papa.parse(detailsText, { header: true }).data;
                const summaryData = Papa.parse(summaryText, { header: true }).data;

                processSummaryData(summaryData);

                // Store globally and init filters
                allDetailsData = detailsData;

                // Init Dept Filter first to check for URL params
                initDeptFilter(allDetailsData);

                // If URL param existed, initDeptFilter might have called updateFilterTreeByDept.
                // If NOT, we need to init item tree with all data.
                // We can check if filterTreeData is empty? or just standard flow.

                // Optimized Flow:
                // 1. initDeptFilter -> determines dept checked state.
                // 2. updateFilterTreeByDept -> filters data based on Depe -> Inits Tree -> Applies Filter.

                // So simply calling initDeptFilter then updateFilterTreeByDept covers ALL cases?
                // Yes. 
                // If no filter param, all depts checked -> updateFilterTreeByDept use all data -> initTree(all) -> applyFilter(all).
                // If filter param, specific dept checked -> updateFilterTreeByDept use subset -> initTree(subset) -> applyFilter(subset).

                updateFilterTreeByDept();

                // processDetailsData(allDetailsData); // Removed, as updateFilterTreeByDept calls applyFilter() -> processDetailsData()

                // But wait, updateFilterTreeByDept calls applyFilter which calls processDetailsData.
                // So we are good.

                // Success Indicator
                document.getElementById('data-source').innerHTML = '<span class="text-emerald-400">● Live Data (CSV)</span>';

            } catch (error) {
                console.warn("Fetching CSVs failed, using fallback mock data.", error);
                // Fallback Mock Data in case of file protocol restrictions (CORS)
                useFallbackData();
            }
        }

        function useFallbackData() {
            // Error Indicator
            document.getElementById('data-source').innerHTML = '<span class="text-rose-400">● Demo Data (CORS/Error)</span>';

            const mockSummary = [
                { Category: "수익", PrevYearPerf: "15800", CurrYearPlan: "16500", CurrYearOrgGoal: "17000", CurrYearSGGoal: "18500" },
                { Category: "영업이익", PrevYearPerf: "4500", CurrYearPlan: "5200", CurrYearOrgGoal: "5800", CurrYearSGGoal: "6500" }
            ];

            const mockDetails = [
                { LV1: "수익", LV2: "결제수수료", LV3: "신용카드", LV4: "가맹점수수료", Dept: "영업1팀", PrevMonthRate: "104.2", CurrMonthGoal: "450", CurrMonthEst: "460", CurrMonthRate: "102.2", CurrYearGoal: "5500" },
                { LV1: "수익", LV2: "결제수수료", LV3: "신용카드", LV4: "할부수수료", Dept: "영업1팀", PrevMonthRate: "101.7", CurrMonthGoal: "110", CurrMonthEst: "115", CurrMonthRate: "104.5", CurrYearGoal: "1300" },
                { LV1: "수익", LV2: "결제수수료", LV3: "체크카드", LV4: "가맹점수수료", Dept: "영업2팀", PrevMonthRate: "104.2", CurrMonthGoal: "220", CurrMonthEst: "230", CurrMonthRate: "104.5", CurrYearGoal: "2700" },
                { LV1: "수익", LV2: "결제수수료", LV3: "체크카드", LV4: "후불교통", Dept: "영업2팀", PrevMonthRate: "103.3", CurrMonthGoal: "25", CurrMonthEst: "26", CurrMonthRate: "104.0", CurrYearGoal: "320" },
                { LV1: "수익", LV2: "결제수수료", LV3: "법인카드", LV4: "공용카드", Dept: "법인영업팀", PrevMonthRate: "101.4", CurrMonthGoal: "130", CurrMonthEst: "135", CurrMonthRate: "103.8", CurrYearGoal: "1600" },
                { LV1: "수익", LV2: "결제수수료", LV3: "간편결제", LV4: "앱카드", Dept: "디지털사업팀", PrevMonthRate: "110.0", CurrMonthGoal: "100", CurrMonthEst: "110", CurrMonthRate: "110.0", CurrYearGoal: "1200" },
                { LV1: "수익", LV2: "금융수익", LV3: "카드론", LV4: "이자수익", Dept: "금융사업팀", PrevMonthRate: "102.8", CurrMonthGoal: "310", CurrMonthEst: "320", CurrMonthRate: "103.2", CurrYearGoal: "3800" },
                { LV1: "수익", LV2: "금융수익", LV3: "현금서비스", LV4: "취급수수료", Dept: "금융사업팀", PrevMonthRate: "96.0", CurrMonthGoal: "90", CurrMonthEst: "85", CurrMonthRate: "94.4", CurrYearGoal: "1100" },
                { LV1: "수익", LV2: "금융수익", LV3: "리볼빙", LV4: "이자수익", Dept: "금융사업팀", PrevMonthRate: "102.5", CurrMonthGoal: "80", CurrMonthEst: "82", CurrMonthRate: "102.5", CurrYearGoal: "950" },
                { LV1: "수익", LV2: "플랫폼수익", LV3: "데이터사업", LV4: "데이터판매", Dept: "데이터사업팀", PrevMonthRate: "112.0", CurrMonthGoal: "50", CurrMonthEst: "55", CurrMonthRate: "110.0", CurrYearGoal: "600" },
                { LV1: "수익", LV2: "플랫폼수익", LV3: "쇼핑몰", LV4: "중개수수료", Dept: "커머스팀", PrevMonthRate: "91.7", CurrMonthGoal: "25", CurrMonthEst: "22", CurrMonthRate: "88.0", CurrYearGoal: "300" },
                { LV1: "수익", LV2: "구독서비스", LV3: "정기구독", LV4: "넷플릭스제휴", Dept: "마케팅팀", PrevMonthRate: "116.7", CurrMonthGoal: "15", CurrMonthEst: "18", CurrMonthRate: "120.0", CurrYearGoal: "150" },
                { LV1: "영업이익", LV2: "결제이익", LV3: "신용카드", LV4: "마진", Dept: "영업1팀", PrevMonthRate: "105.0", CurrMonthGoal: "80", CurrMonthEst: "85", CurrMonthRate: "106.3", CurrYearGoal: "950" },
                { LV1: "영업이익", LV2: "결제이익", LV3: "간편결제", LV4: "마진", Dept: "디지털사업팀", PrevMonthRate: "110.0", CurrMonthGoal: "20", CurrMonthEst: "25", CurrMonthRate: "125.0", CurrYearGoal: "250" },
                { LV1: "영업이익", LV2: "금융이익", LV3: "카드론", LV4: "SPREAD", Dept: "금융사업팀", PrevMonthRate: "106.3", CurrMonthGoal: "140", CurrMonthEst: "150", CurrMonthRate: "107.1", CurrYearGoal: "1700" },
                { LV1: "영업이익", LV2: "금융이익", LV3: "리볼빙", LV4: "SPREAD", Dept: "금융사업팀", PrevMonthRate: "103.6", CurrMonthGoal: "28", CurrMonthEst: "30", CurrMonthRate: "107.1", CurrYearGoal: "320" },
                { LV1: "영업이익", LV2: "비용", LV3: "판관비", LV4: "인건비", Dept: "인사팀", PrevMonthRate: "97.6", CurrMonthGoal: "-350", CurrMonthEst: "-355", CurrMonthRate: "98.6", CurrYearGoal: "-4200" },
                { LV1: "영업이익", LV2: "비용", LV3: "판관비", LV4: "임차료", Dept: "총무팀", PrevMonthRate: "100.0", CurrMonthGoal: "-42", CurrMonthEst: "-42", CurrMonthRate: "100.0", CurrYearGoal: "-520" },
                { LV1: "영업이익", LV2: "비용", LV3: "마케팅비", LV4: "포인트적립", Dept: "마케팅팀", PrevMonthRate: "96.3", CurrMonthGoal: "-220", CurrMonthEst: "-230", CurrMonthRate: "95.7", CurrYearGoal: "-2800" },
                { LV1: "영업이익", LV2: "비용", LV3: "마케팅비", LV4: "유치수수료", Dept: "마케팅팀", PrevMonthRate: "96.2", CurrMonthGoal: "-90", CurrMonthEst: "-95", CurrMonthRate: "94.7", CurrYearGoal: "-1100" },
                { LV1: "영업이익", LV2: "비용", LV3: "대손비용", LV4: "대손상각비", Dept: "리스크팀", PrevMonthRate: "109.4", CurrMonthGoal: "-60", CurrMonthEst: "-55", CurrMonthRate: "109.1", CurrYearGoal: "-800" }
            ];

            processSummaryData(mockSummary);

            allDetailsData = mockDetails;
            initFilterTree(allDetailsData);
            processDetailsData(mockDetails);
        }

        // --- 3. Parsing & Visualization ---

        function processSummaryData(data) {
            // Find rows
            const revenue = data.find(row => row.Category && row.Category.includes("수익")) || {};
            const profit = data.find(row => row.Category && row.Category.includes("영업이익")) || {};

            // Render Revenue
            document.getElementById('rev-prev').innerText = formatNumber(revenue.PrevYearPerf);
            document.getElementById('rev-plan').innerText = formatNumber(revenue.CurrYearPlan);
            document.getElementById('rev-goal').innerText = formatNumber(revenue.CurrYearOrgGoal);
            renderChart('revenueChart', revenue, '#14b8a6'); // Teal

            // Render Profit
            document.getElementById('prof-prev').innerText = formatNumber(profit.PrevYearPerf);
            document.getElementById('prof-plan').innerText = formatNumber(profit.CurrYearPlan);
            document.getElementById('prof-goal').innerText = formatNumber(profit.CurrYearOrgGoal);
            renderChart('profitChart', profit, '#3b82f6'); // Blue
        }

        function renderChart(canvasId, data, color) {
            const ctx = document.getElementById(canvasId).getContext('2d');

            // Clean data
            const values = [
                parseNum(data.PrevYearPerf),
                parseNum(data.CurrYearPlan),
                parseNum(data.CurrYearOrgGoal),
                parseNum(data.CurrYearSGGoal)
            ];

            if (window[canvasId + 'Inst']) window[canvasId + 'Inst'].destroy();

            window[canvasId + 'Inst'] = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: ['전년실적', '경영계획', '조직목표', 'SG도전'],
                    datasets: [{
                        label: '금액 (억)',
                        data: values,
                        backgroundColor: (ctx) => {
                            const v = ctx.raw;
                            const max = Math.max(...values);
                            if (v === max) return color;
                            return color + '80';
                        },
                        borderRadius: 6,
                        barThickness: 40,
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            backgroundColor: '#1e293b',
                            titleColor: '#fff',
                            bodyColor: '#cbd5e1',
                            borderColor: '#334155',
                            borderWidth: 1,
                            padding: 10
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            grid: { color: '#334155', drawBorder: false },
                            ticks: { color: '#94a3b8' }
                        },
                        x: {
                            grid: { display: false },
                            ticks: { color: '#e2e8f0', font: { weight: '500' } }
                        }
                    }
                }
            });
        }

        function processDetailsData(data) {
            const tbody = document.getElementById('details-table-body');
            tbody.innerHTML = '';

            // 1. Group Data: LV1 -> LV2 -> LV3
            const hierarchy = {};

            data.forEach(row => {
                if (!row.LV1) return;

                // Init LV1
                if (!hierarchy[row.LV1]) hierarchy[row.LV1] = { items: [], subgroups: {}, stats: createStats() };
                accumulateStats(hierarchy[row.LV1].stats, row);

                // Init LV2
                if (!hierarchy[row.LV1].subgroups[row.LV2]) {
                    hierarchy[row.LV1].subgroups[row.LV2] = { items: [], subgroups: {}, stats: createStats() };
                }
                accumulateStats(hierarchy[row.LV1].subgroups[row.LV2].stats, row);

                // Init LV3
                if (!hierarchy[row.LV1].subgroups[row.LV2].subgroups[row.LV3]) {
                    hierarchy[row.LV1].subgroups[row.LV2].subgroups[row.LV3] = { items: [], stats: createStats() };
                }
                accumulateStats(hierarchy[row.LV1].subgroups[row.LV2].subgroups[row.LV3].stats, row);

                // Add Item
                hierarchy[row.LV1].subgroups[row.LV2].subgroups[row.LV3].items.push(row);
            });

            // 2. Render Groups
            let lv1Idx = 0;
            for (const [lv1Name, lv1Data] of Object.entries(hierarchy)) {
                lv1Idx++;
                const lv1Id = `group-${lv1Idx}`;

                // Render LV1 (Total)
                renderRow(tbody, { type: 'LV1', name: lv1Name, stats: calculateRates(lv1Data.stats), id: lv1Id, level: 1 });

                let lv2Idx = 0;
                for (const [lv2Name, lv2Data] of Object.entries(lv1Data.subgroups)) {
                    lv2Idx++;
                    const lv2Id = `${lv1Id}-${lv2Idx}`;

                    // Render LV2 (Subtotal)
                    renderRow(tbody, { type: 'LV2', name: lv2Name, stats: calculateRates(lv2Data.stats), id: lv2Id, parentId: lv1Id, level: 2 });

                    let lv3Idx = 0;
                    for (const [lv3Name, lv3Data] of Object.entries(lv2Data.subgroups)) {
                        lv3Idx++;
                        const lv3Id = `${lv2Id}-${lv3Idx}`;

                        // Render LV3 (Subtotal)
                        renderRow(tbody, { type: 'LV3', name: lv3Name, stats: calculateRates(lv3Data.stats), id: lv3Id, parentId: lv2Id, level: 3 });

                        // Render Items (LV4)
                        lv3Data.items.forEach(item => {
                            // Calculate stats dynamically for ITEM level too to ensure consistency
                            const itemStats = {
                                PrevMonthGoalCum: parseNum(item.PrevMonthGoalCum),
                                PrevMonthPerfCum: parseNum(item.PrevMonthPerfCum),
                                CurrMonthGoal: parseNum(item.CurrMonthGoal),
                                CurrMonthEst: parseNum(item.CurrMonthEst),
                                CurrYearGoal: parseNum(item.CurrYearGoal)
                            };
                            const calculatedItem = {
                                ...item, // keep original text fields (LV4, Dept)
                                ...calculateRates(itemStats) // overwrite Rates with calculated ones
                            };

                            renderRow(tbody, { type: 'ITEM', data: calculatedItem, parentId: lv3Id, level: 4 });
                        });
                    }
                }
            }
        }

        function createStats() {
            return {
                PrevMonthGoalCum: 0,
                PrevMonthPerfCum: 0,
                CurrMonthGoal: 0,
                CurrMonthEst: 0,
                CurrYearGoal: 0
            };
        }

        function accumulateStats(stats, row) {
            stats.PrevMonthGoalCum += parseNum(row.PrevMonthGoalCum || 0);
            stats.PrevMonthPerfCum += parseNum(row.PrevMonthPerfCum || 0);
            stats.CurrMonthGoal += parseNum(row.CurrMonthGoal || 0);
            stats.CurrMonthEst += parseNum(row.CurrMonthEst || 0);
            stats.CurrYearGoal += parseNum(row.CurrYearGoal || 0);
        }

        function calculateRates(stats) {
            return {
                ...stats,
                PrevMonthRate: stats.PrevMonthGoalCum ? (stats.PrevMonthPerfCum / stats.PrevMonthGoalCum * 100).toFixed(1) : 0,
                CurrMonthRate: stats.CurrMonthGoal ? (stats.CurrMonthEst / stats.CurrMonthGoal * 100).toFixed(1) : 0
            };
        }

        // --- Toggle Logic ---
        window.toggleRow = function (id) {
            const row = document.getElementById(id); // The row header itself (if we want to style it)
            const caret = document.getElementById(`caret-${id}`);

            // Toggle Caret
            if (caret) caret.classList.toggle('caret-open');

            // Find all immediate children
            const children = document.querySelectorAll(`[data-parent-id="${id}"]`);

            children.forEach(child => {
                const isHidden = child.style.display === 'none';
                if (isHidden) {
                    // Show row
                    child.style.display = '';
                    // BUT: If this child is itself a group that is collapsed, do NOT show its children
                    // We only show direct children. Their children state is preserved by their own logic?
                    // Actually, simple logic: Toggle direct children.
                    // If opening, check if the child is a group (has a caret). If it has a caret that is OPEN, we should recursively open?
                    // No, simpler: Just toggle direct children display.

                    // However, if we show a child row which is an LV2/LV3 header, and IT was closed, their children remain closed (display:none).
                    // This works naturally because we only target `[data-parent-id="${id}"]`.
                } else {
                    // Hide row
                    child.style.display = 'none';
                    // Recursively hide descendants!
                    // If we hide LV1, we must also ensure LV2's children are hidden, etc.
                    // We can do this by finding all rows that are descendants.
                    hideRecursively(child.id);
                }
            });
        };

        function hideRecursively(parentId) {
            if (!parentId) return;
            const children = document.querySelectorAll(`[data-parent-id="${parentId}"]`);
            children.forEach(child => {
                child.style.display = 'none';
                hideRecursively(child.id);
            });
        }


        function renderRow(tbody, { type, name, stats, data, id, parentId, level }) {
            const tr = document.createElement('tr');
            if (id) tr.id = id;
            if (parentId) tr.setAttribute('data-parent-id', parentId);

            // --- Styling per level ---
            let bgClass = "";
            let nameCell = "";
            let prevRate, currGoal, currEst, currRate, yearGoal;

            // Indentation logic
            const paddingLeft = (level - 1) * 1.5;

            if (type === 'ITEM') {
                tr.className = "hover:bg-slate-800/50 transition-colors border-b border-dark-border";

                // Dept Column
                let deptHtml = '-';
                if (data.Dept) {
                    const depts = data.Dept.split(',').map(d => d.trim());
                    // Use flex-col to force new lines
                    deptHtml = depts.map(d =>
                        `<div class="inline-block px-2 py-0.5 rounded text-[11px] font-bold tracking-wider bg-slate-700 text-slate-300 border border-slate-600 whitespace-nowrap mb-1 last:mb-0 text-center w-fit">${d}</div>`
                    ).join('');
                }

                tr.innerHTML = `
                    <td class="px-4 py-3 font-medium text-white whitespace-nowrap">${data.LV1 || '-'}</td>
                    <td class="px-4 py-3 whitespace-nowrap">${data.LV2 || '-'}</td>
                    <td class="px-4 py-3 whitespace-nowrap">${data.LV3 || '-'}</td>
                    <td class="px-4 py-3 whitespace-nowrap">${data.LV4 || '-'}</td>
                    <td class="px-4 py-3">
                        <div class="flex flex-col items-start gap-1">
                            ${deptHtml}
                        </div>
                    </td>
                    <td class="px-4 py-3 text-right text-slate-400">${formatNumber(data.PrevMonthRate)}%</td>
                    <td class="px-4 py-3 text-right">${formatNumber(data.CurrMonthGoal)}</td>
                    <td class="px-4 py-3 text-right font-medium text-white">${formatNumber(data.CurrMonthEst)}</td>
                    <td class="px-4 py-3 text-right font-bold ${getRateColor(data.CurrMonthRate)}">${formatNumber(data.CurrMonthRate)}%</td>
                    <td class="px-4 py-3 text-right text-slate-400">${formatNumber(data.CurrYearGoal)}</td>
                `;

            } else {
                // Header Rows (LV1, LV2, LV3)
                // stats is passed as argument
                let nameCell = '';

                // Add Caret
                const caret = `<i id="caret-${id}" class="ph-bold ph-caret-right caret-icon caret-open inline-block mr-2"></i>`;
                const clickAttr = `onclick="toggleRow('${id}')" style="cursor: pointer;"`;

                if (type === 'LV1') {
                    tr.className = "bg-slate-700/50 border-b border-white/10 font-bold text-white hover:bg-slate-700/70";
                    nameCell = `
                        <td class="px-4 py-3 text-brand-500 text-lg group-total" colspan="5" ${clickAttr}>
                            ${caret} ${name} <span class="text-sm font-normal text-slate-300 ml-2">Total</span>
                        </td>
                    `;
                } else if (type === 'LV2') {
                    tr.className = "bg-slate-800/80 border-b border-dark-border font-medium hover:bg-slate-800";
                    nameCell = `
                        <td class="px-4 py-3"></td>
                        <td class="px-4 py-3 text-brand-100" colspan="4" ${clickAttr}>
                            ${caret} ${name} <span class="text-xs text-slate-400 bg-slate-700 px-1.5 rounded ml-2">Subtotal</span>
                        </td>
                    `;
                } else if (type === 'LV3') {
                    tr.className = "bg-slate-800/40 border-b border-dark-border font-medium text-slate-200 hover:bg-slate-800/60";
                    nameCell = `
                        <td class="px-4 py-3"></td>
                        <td class="px-4 py-3"></td>
                        <td class="px-4 py-3" colspan="3" ${clickAttr}>
                            ${caret} ${name}
                        </td>
                    `;
                }

                prevRate = stats.PrevMonthRate;
                currGoal = stats.CurrMonthGoal;
                currEst = stats.CurrMonthEst;
                currRate = stats.CurrMonthRate;
                yearGoal = stats.CurrYearGoal;

                let rateClass = getRateColor(currRate);
                if (type === 'LV1') rateClass += " text-lg";

                tr.innerHTML = `
                    ${nameCell}
                    <td class="px-4 py-3 text-right ${parseFloat(prevRate) >= 100 ? 'text-emerald-400' : 'text-slate-300'}">${formatNumber(prevRate)}%</td>
                    <td class="px-4 py-3 text-right text-slate-400">${formatNumber(currGoal)}</td>
                    <td class="px-4 py-3 text-right text-white">${formatNumber(currEst)}</td>
                    <td class="px-4 py-3 text-right ${rateClass}">${formatNumber(currRate)}%</td>
                    <td class="px-4 py-3 text-right text-white">${formatNumber(yearGoal)}</td>
                `;
            }

            tbody.appendChild(tr);
        }

        // Helper function for rate coloring (used by ITEM type)
        function getRateColor(rate) {
            const rateVal = parseFloat(rate);
            if (rateVal >= 100) return "text-emerald-400";
            if (rateVal < 90) return "text-rose-400";
            return "text-slate-300";
        }

        // --- 4. Search Functionality ---
        document.getElementById('searchInput').addEventListener('keyup', function (e) {
            const term = e.target.value.toLowerCase();
            const allRows = document.querySelectorAll('#details-table-body tr');

            // Simple approach: Show row if text matches, otherwise hide
            // BUT: With hierarchy it's tricky.
            // Better approach: If search is empty, Restore all to 'table-row' (or respect hierarchy? Hard to respect hierarchy state easily).
            // For now: Just filter all rows properly.

            if (term === '') {
                // Reset: Show everything? Or just reload data to reset state?
                // Reloading data is safest to reset toggle state
                loadData();
                return;
            }

            allRows.forEach(row => {
                const text = row.textContent.toLowerCase();
                // If it's a header row (LV1/LV2/LV3), always show it if ANY of its children match?
                // Or just show if the row itself matches?
                // Simplification for search: Just show matching rows.
                if (text.includes(term)) {
                    row.style.display = '';
                } else {
                    row.style.display = 'none';
                }
            });
        });

        // --- Filter Tree Logic ---

        function initFilterTree(data) {
            // Build hierarchy from data
            const tree = [];
            const levels = ['LV1', 'LV2', 'LV3', 'LV4'];

            function findOrAdd(array, name, level, ids, parent) {
                let item = array.find(i => i.name === name);
                if (!item) {
                    // Generate unique ID based on path
                    const id = ids.join('-');
                    item = {
                        name,
                        level,
                        id,
                        children: [],
                        checked: true, // Default ON
                        path: [...ids],
                        parent: parent // Add parent reference
                    };
                    array.push(item);
                }
                return item;
            }

            data.forEach(row => {
                if (!row.LV1) return;

                let currentLevel = tree;
                let pathIds = [];

                // LV1
                pathIds.push(row.LV1);
                let lv1 = findOrAdd(currentLevel, row.LV1, 1, pathIds, null);

                // LV2
                if (row.LV2) {
                    pathIds.push(row.LV2);
                    let lv2 = findOrAdd(lv1.children, row.LV2, 2, pathIds, lv1);

                    // LV3
                    if (row.LV3) {
                        pathIds.push(row.LV3);
                        let lv3 = findOrAdd(lv2.children, row.LV3, 3, pathIds, lv2);

                        // LV4 (Leaf)
                        if (row.LV4) {
                            pathIds.push(row.LV4);
                            findOrAdd(lv3.children, row.LV4, 4, pathIds, lv3);
                        }
                    }
                }
            });

            filterTreeData = tree;
            renderFilterTree();
        }

        function renderFilterTree() {
            const container = document.getElementById('filter-tree');
            container.innerHTML = '';

            function createNode(item) {
                const node = document.createElement('div');
                node.className = 'tree-node';

                const isLeaf = item.children.length === 0;

                // Row
                const row = document.createElement('div');
                row.className = 'tree-row';

                // Caret
                const caret = document.createElement('div');
                caret.className = `tree-caret ${isLeaf ? 'leaf' : 'expanded'}`;
                caret.innerHTML = isLeaf ? '' : '<i class="ph-bold ph-caret-right"></i>';
                if (!isLeaf) {
                    caret.onclick = (e) => {
                        e.stopPropagation();
                        caret.classList.toggle('expanded');
                        const childrenContainer = node.querySelector('.tree-children');
                        if (childrenContainer) {
                            childrenContainer.classList.toggle('expanded');
                            // Also toggle hidden class for safety/logic if needed, but CSS handles sticky
                            if (childrenContainer.style.display === 'none') {
                                childrenContainer.style.display = 'block';
                            } else {
                                childrenContainer.style.display = 'none';
                            }
                        }
                    };
                }

                // Checkbox
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.className = 'tree-checkbox';
                checkbox.checked = item.checked;
                checkbox.indeterminate = item.indeterminate || false; // Set visual state
                checkbox.dataset.id = item.id;
                checkbox.onchange = () => toggleFilter(item, checkbox.checked);

                // Label
                const label = document.createElement('span');
                label.className = 'tree-label';
                label.innerText = item.name;
                label.onclick = () => { if (!isLeaf) caret.click(); }; // Label click toggles expand

                row.appendChild(caret);
                row.appendChild(checkbox);
                row.appendChild(label);
                node.appendChild(row);

                // Children
                if (!isLeaf) {
                    const childrenDiv = document.createElement('div');
                    childrenDiv.className = 'tree-children expanded'; // Default expanded
                    // Sync display with caret
                    childrenDiv.style.display = 'block';

                    item.children.forEach(child => {
                        childrenDiv.appendChild(createNode(child));
                    });
                    node.appendChild(childrenDiv);
                }

                return node;
            }

            filterTreeData.forEach(rootItem => {
                container.appendChild(createNode(rootItem));
            });
        }

        function expandAll(expand) {
            const carets = document.querySelectorAll('.tree-caret:not(.leaf)');
            const children = document.querySelectorAll('.tree-children');

            carets.forEach(c => {
                if (expand) c.classList.add('expanded');
                else c.classList.remove('expanded');
            });

            children.forEach(c => {
                c.style.display = expand ? 'block' : 'none';
            });
        }

        function toggleFilter(item, isChecked) {
            // Update Data Model
            updateCheckState(item, isChecked);

            // Re-render Tree to update UI (simplest way to ensure consistent state visuals)
            // Optimization: Update DOM directly for better performance, but re-rendering is safer for sync
            // For now, re-render is fine for this dataset size.
            renderFilterTree();

            // Apply Filter
            applyFilter();
        }


        // --- Dept Filter Logic ---

        function initDeptFilter(data) {
            // Get unique departments (handling multiple values per row: "A, B")
            const depts = new Set();
            data.forEach(row => {
                if (row.Dept) {
                    const rowDepts = row.Dept.split(',').map(d => d.trim());
                    rowDepts.forEach(d => depts.add(d));
                }
            });

            // Convert to array of objects
            const urlParams = new URL(window.location).searchParams;
            const filterParam = urlParams.get('filter') ? decodeURIComponent(urlParams.get('filter')) : null;

            deptFilterData = Array.from(depts).sort().map(name => {
                let initialChecked = true;
                if (filterParam) {
                    // If filter param exists, only check if name includes or equals the param
                    // Let's use exact match or partial if convenient. User said "filter=영업2팀".
                    // Let's support exact match first, or comma separated?
                    // "default로 영업2팀만 필터링해서 보이도록" implies others are unchecked.

                    if (depts.has(filterParam)) {
                        // Exact match found in data
                        initialChecked = (name === filterParam);
                    } else {
                        // Fallback: If param doesn't match any dept exactly, keep all checked? 
                        // Or maybe partial match? Let's do exact match to be safe.
                        // Wait, if I type ?filter=영업, maybe I want all sales?
                        // Let's strict match for now as requested.
                        initialChecked = (name === filterParam);
                    }
                }

                return {
                    name: name,
                    checked: initialChecked
                };
            });

            // If we filtered, we should ensure at least one is checked? 
            // If user provides invalid filter, everything will be unchecked.
            // Let's checking if ANY is checked. If none, revert to ALL checked (fallback).
            const anyChecked = deptFilterData.some(d => d.checked);
            if (!anyChecked && filterParam) {
                console.warn(`Filter param '${filterParam}' not found in departments. Showing all.`);
                deptFilterData.forEach(d => d.checked = true);
            } else if (filterParam) {
                // If filter was applied, we should also trigger the tree update!
                // Since initDeptFilter determines state, the subsequent render calls will use this state.
                // But we need to make sure updateFilterTreeByDept is called OR initFilterTree is called with filtered data.

                // Currently code flow:
                // loadData -> initFilterTree(all) -> initDeptFilter(all) -> processDetailsData(all)

                // We need:
                // loadData -> initDeptFilter(all) [calculates state] -> updateFilterTreeByDept() [which calls initFilterTree & applyFilter]

                // So in loadData, we should change order?
                // Or just let initDeptFilter call updateFilterTreeByDept() at the end?
                // Let's Modify loadData flow.
            }

            renderDeptFilter();
            // Important: If we have a filter, we must update the Item Tree to match!
            if (filterParam && anyChecked) {
                // Trigger the update logic which filters data and re-inits item tree
                updateFilterTreeByDept();
            } else {
                // Normal flow, just render dept filter. Item tree is already init with ALL data in loadData.
                // Actually, updateFilterTreeByDept() does everything (filter data -> init item tree -> apply filter).
                // So we can arguably ALWAYS call updateFilterTreeByDept() instead of explicit initFilterTree in loadData?
                // Let's just call it if filter param exists, to override the initial state.
                // OR simpler: Always call updateFilterTreeByDept inside initDeptFilter?
                // No, initDeptFilter is called ONCE.
            }
        }

        function renderDeptFilter() {
            const container = document.getElementById('dept-filter-list');
            container.innerHTML = '';

            deptFilterData.forEach(dept => {
                const node = document.createElement('div');
                node.className = 'tree-node flex items-center gap-2 mb-1 pl-1 hover:bg-white/5 rounded py-1 cursor-pointer';

                // Checkbox
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.className = 'tree-checkbox';
                checkbox.checked = dept.checked;
                checkbox.onchange = (e) => {
                    dept.checked = e.target.checked;
                    updateFilterTreeByDept(); // Rebuild Item Tree
                };

                // Label
                const label = document.createElement('span');
                label.className = 'tree-label text-sm text-slate-300';
                label.innerText = dept.name;
                label.onclick = () => checkbox.click(); // Label click toggles checkbox

                node.appendChild(checkbox);
                node.appendChild(label);
                container.appendChild(node);
            });
        }

        function toggleAllDepts(isChecked) {
            deptFilterData.forEach(d => d.checked = isChecked);
            renderDeptFilter();
            updateFilterTreeByDept(); // Rebuild Item Tree
        }

        function updateFilterTreeByDept() {
            // 1. Get Selected Depts
            const checkedDepts = new Set(deptFilterData.filter(d => d.checked).map(d => d.name));

            // 2. Filter All Data by Dept
            const filteredDataForTree = allDetailsData.filter(row => {
                if (!row.LV1) return false;
                // If Dept exists, check if ANY of its depts are selected (OR logic for intersection)
                // or exact? Usually if Row has "A, B", and I select "A", it should appear.
                if (row.Dept) {
                    const rowDepts = row.Dept.split(',').map(d => d.trim());
                    const hasOverlap = rowDepts.some(d => checkedDepts.has(d));
                    if (!hasOverlap) return false;
                }
                return true;
            });

            // 3. Re-Init Item Filter Tree with Filtered Data
            // This will reset checkboxes to TRUE for visible items (Default behavior)
            // Or we could try to preserve state if needed, but "Update items" implies refreshing list.
            initFilterTree(filteredDataForTree);

            // If filter param exists, maybe we want to EXPAND the tree to show the selected items?
            // "Default로 영업2팀만 필터링해서 보이도록" -> Filter applied.
            // Expanding is nice UX.
            if (filteredDataForTree.length < 50) { // arbitrary threshold
                expandAll(true);
            }

            // 4. Update Table View (Apply Filters)
            applyFilter();
        }


        function updateCheckState(item, isChecked, isPropagation = false) {
            // 1. Update Self
            item.checked = isChecked;
            item.indeterminate = false; // Reset indeterminate on explicit change

            // 2. Propagate Down (Top-Down)
            // Only propagate down if this call originated from user interaction (not propagation)
            // OR if strictly enforcing parent -> child sync.
            // If user clicks parent, we force children to match.
            // If function called as updateParent, we DO NOT touch children.
            if (!isPropagation && item.children && item.children.length > 0) {
                item.children.forEach(child => updateCheckState(child, isChecked));
            }

            // 3. Propagate Up (Bottom-Up)
            if (item.parent) {
                updateParentState(item.parent);
            }
        }

        function updateParentState(parent) {
            if (!parent) return;

            const allChecked = parent.children.every(c => c.checked);
            const anyChecked = parent.children.some(c => c.checked || c.indeterminate); // Indeterminate logic

            // Determine Parent State
            if (allChecked) {
                parent.checked = true;
                parent.indeterminate = false;
            } else if (anyChecked) {
                parent.checked = false;
                parent.indeterminate = true;
            } else {
                parent.checked = false;
                parent.indeterminate = false;
            }

            // Recursively update upwards
            updateParentState(parent.parent);
        }

        // To support bottom-up, we need parent references or recursive traversal from root.
        // Let's add parent ref during build? Or just traverse.
        // Let's add parent ref in initFilterTree.

        // Re-implement initFilterTree to add parent refs for easier traversal?
        // Or just re-calculate parent state before render?
        // Let's keep it simple: Top-down only for now as requested.

        function applyFilter() {
            // Gather all checked LV4 IDs (or just paths)
            // Traversing tree to find checked leaf nodes
            // The Tree is now generated based on SELECTED DEPTS only.
            // So we only need to check which tree nodes are checked.

            const checkedPaths = new Set();
            // checkedDepts is implicitly handled by initFilterTree(filteredDataForTree)
            // But we still need dept filter data for processDetailsData if we want strict dual filter?
            // Actually, if Tree only contains items for Selected Depts, then checking Tree Items is enough?
            // Wait. One Item (e.g. Card) can exist in multiple Depts.
            // If I select Dept A, Tree has Card. If I select Dept B, Tree has Card.
            // If I select Dept A & B, Tree has Card.
            // When filtering, I need to know if row.Dept is in Selected Depts.

            const checkedDepts = new Set(deptFilterData.filter(d => d.checked).map(d => d.name));

            function collectChecked(nodes) {
                nodes.forEach(node => {
                    // If leaf and checked, add to set
                    if (node.children.length === 0 && node.checked) {
                        // We need a way to match this against data.
                        // Data has LV1, LV2, LV3, LV4 columns.
                        // Node.path has [LV1, LV2, LV3, LV4].
                        checkedPaths.add(node.path.join('|'));
                    } else if (node.children.length > 0) {
                        // Optimization: if node is unchecked, its children are unchecked (logic).
                        // But if we allow partial selection in future...
                        collectChecked(node.children);
                    }
                });
            }

            collectChecked(filterTreeData);

            // Filter data
            const filtered = allDetailsData.filter(row => {
                if (!row.LV1) return false;

                // Dept Condition
                if (row.Dept) {
                    const rowDepts = row.Dept.split(',').map(d => d.trim());
                    // Check if *any* of the row's depts are in the checkedDepts set
                    const hasOverlap = rowDepts.some(d => checkedDepts.has(d));

                    if (!hasOverlap) return false;
                }

                // Construct path key
                const parts = [row.LV1];
                if (row.LV2) parts.push(row.LV2);
                if (row.LV3) parts.push(row.LV3);
                if (row.LV4) parts.push(row.LV4);

                const key = parts.join('|');
                return checkedPaths.has(key);
            });

            processDetailsData(filtered);
        }

        // --- Original Chart & Table Functions (Keep provided unchanged, just ensure processDetailsData uses args) ---
    </script>
</body>

</html>